---
title: Introduction
description: A Continual Learning Framework for Production LLM Agents
sidebarTitle: Introduction
icon: home
---

<div align="center">
  <img src="/images/ATLAS.png" alt="ATLAS Hero Image"/>
</div>

<br/>

Atlas enables continual learning for production agents. The runtime SDK wraps any agent in an adaptive dual-agent reasoning loop (student + teacher) guided by reward signals that triages tasks, probes capability, and routes to the right supervision lane. Atlas Core turns those runtime episodes into optimized teacher checkpoints with offline reinforcement learning (RL) training.

You get an agent that compounds knowledge over time, building a durable library of domain expertise instead of treating deployment as a static endpoint that needs constant retrainingâ€”while driving down the cost of reasoning models through improved efficiency.

## How It Works: Closed-Loop Learning System

ATLAS wraps any base model (GPT, Claude, Gemini, open source checkpoints, or your own) with an inference-time closed-loop learning system that observes the agent's action space in its live environment. The system executes tasks with built-in quality control that reviews every decision, and the Reward System scores the outcome. That signal can immediately trigger retries or feed downstream training jobs. The same loop powers both the runtime SDK (real-time quality control) and the training stack (offline optimization).

## What ATLAS Provides

ATLAS wraps your existing agent framework with four components that create a complete learning loop:

1. **Reasoning Core**: Dual-agent reasoning loop (student + verifying teacher) that guides execution and captures learning signals
2. **[Reward System](/concepts/reward-design)**: Turns user feedback into dense reward signals (achieves 93.7% accuracy on RewardBench V2)
3. **Learning Engine**: Uses offline reinforcement learning (GRPO) to update models based on rewards. Online continual learning now lives in the atlas-sdk runtime.
4. **Persistent Memory**: Stores all interactions in structured trace files for analysis and retraining

Together, these components form a closed-loop system: interaction traces flow into the reward system, the learning engine upgrades the reasoning core, and the refreshed models redeploy so your agent improves performance with each task.

<div align="center">
  <img src="/images/system-architecture.png" alt="ATLAS System Architecture" width="800" />
  <p><em>ATLAS keeps your agent in a learnâ€“evaluateâ€“update cycle.</em></p>
</div>

## Runtime for ML Engineers

The Atlas SDK wraps any agent and turns every task into a structured learning episode. Install it to get started:

```bash
pip install arc-atlas
```

Clone the [`atlas-sdk`](https://github.com/Arc-Computer/atlas-sdk) repository if you want the ready-made configs and examples.

- **Runtime orchestrator** â€“ `atlas.core.run` triages every task, runs a capability probe, routes it into `auto`, `paired`, `coach`, or `escalate`, and then wraps your agent in an adaptive dual-agent reasoning loop guided by reward signals: your agent (the student) collaborates with a verifying teacher that reviews every decision while telemetry streams through `atlas.runtime.telemetry`.
- **Runtime exports** â€“ every run streams structured traces and reward signals into Postgres (`storage` block) and exports JSONL via the SDK CLI (`arc-atlas --database-url ... --output traces.jsonl`). You own the dataset that reflects how your production agent actually behaves.
- **Training pipeline** â€“ feed those traces straight into the offline stack via the [`Runtime Traces dataset config`](/training/configuration#dataset-presets) and the GRPO trainers to ship bespoke teachers or policy checkpoints without hand-labeling.

<Note>
**Data Ownership**: Atlas never modifies model weights during runtimeâ€”only RL training (which you control) updates weights. Trace storage is optional and self-hosted. You own all data.
</Note>

The runtime provides immediate quality improvements through dual-agent orchestration. Export the same traces to train custom checkpoints with GRPOâ€”captured traces become training data for both runtime and offline RL training. Online continual learning now lives in the [atlas-sdk](https://github.com/Arc-Computer/atlas-sdk) repository.

### End-to-End Lifecycle at a Glance

| Stage | Run This | Output | Typical Effort |
|-------|-----------|--------|----------------|
| Runtime quality control | [`atlas.core.run(..., stream_progress=True)`](/sdk/quickstart) | Reviewed plan, per-step traces, live reward scores | Minutes |
| Persist + export | [`storage:` block](/sdk/configuration) + [`arc-atlas --database-url â€¦ --output traces.jsonl`](/sdk/export-traces) | JSONL dataset mirroring production behaviour | Minutes |
| Export + train workflow | [`scripts/run_offline_pipeline.py`](https://github.com/Arc-Computer/ATLAS/blob/main/scripts/run_offline_pipeline.py) | Convert runtime traces into a new teacher checkpoint | Minutes to launch (training time depends on compute) |
| Custom training | [GRPO pipeline](/training/offline/grpo-training) | Bespoke teacher checkpoint, ready to deploy | Multi-hour job on GPUs |

Every stage feeds the nextâ€”runtime traces become the input for optimization and training.

## Getting Started: Two Paths

Choose your starting point based on your goal:

<Info>
ðŸ”§ Ready to ship code? Start with the [`SDK Quickstart`](/sdk/quickstart)â€”it walks through installation, configuration, and running your first dual-agent task in minutes.
</Info>

<div align="center">
  <video
    controls
    width="800"
    style={{borderRadius: '12px'}}
    src="/images/Atlas.sdk-high.mp4"
  >
  </video>
  <p><em>See the Atlas SDK in action: from installation to measurable performance gains across real examples.</em></p>
</div>

<br/>

| I want to... | Use this Path | Key Docs |
|--------------|----------|--------------|
| Orchestrate tasks with a structured runtime loop. | Atlas SDK | [`SDK Quickstart`](/sdk/quickstart) |
| Wrap my existing agent in a quality-control loop. | Atlas SDK | [`BYOA Adapters`](/sdk/adapters) |
| Convert runtime traces into GRPO training runs. | Atlas Core | [`Offline Training Guide`](/training/offline/grpo-training) |
| Fine-tune a custom model with RL. | Training & Optimization | [`Offline Training Guide`](/training/offline/grpo-training) |

Choose your starting point:

<CardGroup cols="2">
  <Card title="SDK Runtime Orchestration" icon="workflow" href="/sdk/quickstart">
    Use the Atlas orchestrator to run an existing agent with a closed-loop learning system. Get started in minutes.
  </Card>
  <Card title="Offline Training (Atlas Core)" icon="graduation-cap" href="/training/offline/grpo-training">
    Convert exported runtime traces into GRPO training jobs, evaluate reward deltas, and ship updated teacher checkpoints.
  </Card>
</CardGroup>

## Research & Resources

Learn more about the methodology and science behind ATLAS:

- [ATLAS Technical Report (PDF)](/ATLAS-Technical-Report.pdf) - Complete methodology, benchmarks, and implementation details
- [Arc Research](https://www.arc.computer/research) - Our latest research advancing continual learning systems
- [GitHub Repository](https://github.com/Arc-Computer/ATLAS) - Source code, examples, and issue tracking
- [HuggingFace Models](https://huggingface.co/Arc-Intelligence) - Pre-trained models
